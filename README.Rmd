---
title: "Intensity Functional Principal Component Analysis (IFPCA)"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE}
library(tidyverse)
library(doParallel)
source("R/GetPK.R")
source("R/masta-fpca-main.R")
source("R/masta-fpca-kern.R")
url <- "data-raw/long/"
follow_up_train <- read_csv(paste0(url, "follow_up_train.csv"))
follow_up_valid <- read_csv(paste0(url, "follow_up_valid.csv"))
time_code1 <- read_csv(paste0(url, "time_code1.csv"))
time_code2 <- read_csv(paste0(url, "time_code2.csv"))
time_code3 <- read_csv(paste0(url, "time_code3.csv"))
```

```{r}
fu_train <- follow_up_train$fu_time
fu_valid <- follow_up_valid$fu_time
names(fu_train) <- follow_up_train$id
names(fu_valid) <- follow_up_valid$id
str(fu_train)
str(fu_valid)
```

```{r}
time1 <- time_code1$month
time2 <- time_code2$month
time3 <- time_code3$month
names(time1) <- time_code1$id
names(time2) <- time_code2$id
names(time3) <- time_code3$id
str(time1)
str(time2)
str(time3)
```

```{r}
#' @title Intensity Functional Principal Component Analysis (IFPCA)
#' @description Performs IFPCA to extract features from longitudinal encounter data.
#' @param data input data. See \code{data(data_org)} for example.
#' @param PPIC_K a logical indicating whether you want to use Pseudo-Poisson Information Criterion to choose 
#' the number of principal components K (K.select="PPIC") \code{TRUE} or another criterion to choose 
#' K (K.select="PropVar") \code{FALSE} in the PP_FPCA_Parallel function (hidden). Default is \code{FALSE}.
#' @param n.grid an integer value for grid points used in estimating covariance function g. Default is \code{401}.
#' @param propvar a proportion of variation used to select number of FPCs. Default is \code{0.85}.
#' @param n_core an integer to specify the number of core using for parallel computing. 
#' @export
ifpca <- function(time, fu_train, fu_valid, 
                  PPIC_K = FALSE, n.grid = 401, propvar = 0.85, n_core = NULL) {
  if (is.null(n_core)) n_core <- parallel::detectCores()
  registerDoParallel(cores = n_core)    
  tseq <- 0:floor(max(c(fu_train, fu_valid)))
  PKTS <- GetPK(id = names(time), t = time, tseq = tseq, nn = length(fu_train))
  return(PKTS[!is.na(PKTS)])
}
```

```{r}
pkts <- ifpca(time1, fu_train, fu_valid)
str(pkts)
```

```{r}
library(MASTA)
```

```{r}
data <- data_org
TrainSurv <- data.frame(data$TrainSurv)
ValidSurv <- data.frame(data$ValidSurv)
TrainCode <- data.frame(data$TrainCode)
ValidCode <- data.frame(data$ValidCode)
colnames(TrainSurv) <- colnames(ValidSurv) <- c(
  "case", "delta", "sx", "sc", paste0("base_pred", 1:(NCOL(TrainSurv) - 4)))
colnames(TrainCode)[1:2] <- colnames(ValidCode)[1:2] <- c("case", "analysisfu")  
TrainSurv_pred_org <- TrainSurv[-(1:4)]
ValidSurv_pred_org <- ValidSurv[-(1:4)]  
codes <- names(TrainCode[, -(1:3)])
TrainN <- rowsum(TrainCode[, -(1:3)], group = TrainCode[, 1])
ValidN <- rowsum(ValidCode[, -(1:3)], group = ValidCode[, 1])
TrainN <- cbind(case = rownames(TrainN), TrainN)
ValidN <- cbind(case = rownames(ValidN), ValidN)  
colnames(TrainN)[-1] <- paste0(colnames(TrainCode)[-(1:3)], "_total")
colnames(ValidN)[-1] <- paste0(colnames(ValidCode)[-(1:3)], "_total")
TrainPatNum <- unique(TrainCode[, 1])
ValidPatNum <- unique(ValidCode[, 1])
nn <- nrow(TrainSurv) # labeled (training)
nnv <- nrow(ValidSurv) # labeled (validation)
NN <- length(TrainPatNum) - nn # unlabeled  
Tend <- 1
TrainCode$monthstd <- TrainCode$month / TrainCode$analysisfu # standardize follow up time
ValidCode$monthstd <- ValidCode$month / ValidCode$analysisfu # standardize follow up time 
TrainFU <- aggregate(TrainCode$analysisfu, list(TrainCode$case), max)  
ValidFU <- aggregate(ValidCode$analysisfu, list(ValidCode$case), max)
TrainFU <- TrainFU[match(TrainPatNum, TrainFU[, 1]), 2]
ValidFU <- ValidFU[match(ValidPatNum, ValidFU[, 1]), 2]
#--TRAINING---
K <- NULL
ft.e <- ft.e.S <- PKTS <- NULL
FPCA <- vector("list", length(codes))
names(FPCA) <- codes
```

```{r}
i <- 1
print(paste("training:", codes[i]))
tmp2 <- TrainN[, i + 1] > 0
TrainNP <- TrainN[tmp2, i + 1]
### PKs from Two-step procedure
txt <- paste0("t=with(TrainCode,unlist(sapply(seq_along(month),function(j) rep(month[j],",codes[i],"[j]))))")
eval(parse(text = txt))
id <- (1:(nn+NN))[tmp2]
id <- rep(id, TrainNP)
PKTS <- NULL
PKTS <- cbind(PKTS, GetPK(id = id, t = t, tseq = sort(unique(TrainCode$month)), nn = nrow(TrainN)))    
str(PKTS[!is.na(PKTS)])
```

```{r}
sort(unique(TrainCode$month))
```

```{r}
proc.time()
```
